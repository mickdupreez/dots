// Generated by CoffeeScript 1.10.0
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  window.Tab = (function() {
    var closedTabs, fixUrl, markTabs, markedTabs, ref, remove, runWhenComplete;

    function Tab() {}

    ref = [[], null, [], []], closedTabs = ref[0], Tab.previousTab = ref[1], Tab.lastOpenTabs = ref[2], markedTabs = ref[3];

    remove = function(tab) {
      if (!tab) {
        return;
      }
      if (Tab.currentTab.id !== tab.id) {
        Tab.addToClosedTabs(tab);
      }
      return chrome.tabs.remove(tab.id);
    };

    runWhenComplete = function(msg) {
      return chrome.tabs.get(msg.tab.id, function(tab) {
        if (tab.status === 'complete') {
          return runScript(msg);
        } else {
          return setTimeout(runWhenComplete, 100, msg);
        }
      });
    };

    fixUrl = function(url, tab) {
      var keyword, name, ref1, searchengines;
      url = url.trim();
      if (url.isValidURL()) {
        return {
          url: url,
          origin: 'url'
        };
      } else if (((ref1 = url[0]) === '/' || ref1 === '.') && !/\s/.test(url)) {
        return {
          url: fixRelativePath(url, tab.url),
          origin: 'url'
        };
      } else if (/\w+\.\w+/.test(url) && !/\s/.test(url)) {
        return {
          url: "http://" + url,
          origin: 'url'
        };
      } else if (/local(?:host)?(?:$|\/|:)/.test(url) && !/\s/.test(url)) {
        return {
          url: "http://" + url,
          origin: 'url'
        };
      } else {
        searchengines = Option.get('searchengines');
        name = url.replace(/^(\S+)\s.*$/, '$1');
        keyword = encodeURIComponent(url.replace(/^\S+\s+(.*)$/, '$1'));
        if (searchengines[name]) {
          return {
            url: searchengines[name].replace('{{keyword}}', keyword),
            origin: 'search-engine'
          };
        } else {
          url = encodeURIComponent(url);
          return {
            url: Option.defaultSearchUrl(url),
            origin: 'search'
          };
        }
      }
    };

    Tab.autoComplete = function(msg) {
      var bookmarks, completionItems, dataToFetch, defaultUrl, history, returnUrls, startTime;
      defaultUrl = fixUrl(msg.keyword, msg.tab);
      if (Option.get('noautocomplete')) {
        return Post(msg.tab, {
          action: 'Dialog.draw',
          urls: defaultUrl,
          keyword: msg.keyword
        });
      }
      bookmarks = history = null;
      completionItems = Option.get('completion_items').split(',');
      dataToFetch = Number(indexOf.call(completionItems, 'bookmarks') >= 0) + Number(indexOf.call(completionItems, 'history') >= 0);
      returnUrls = function() {
        var i, len, order, urls;
        urls = [];
        for (i = 0, len = completionItems.length; i < len; i++) {
          order = completionItems[i];
          switch (order) {
            case 'search-engine':
              if (defaultUrl.origin === 'search-engine') {
                urls = urls.concat(defaultUrl);
              }
              break;
            case 'url':
              if (defaultUrl.origin === 'url') {
                urls = urls.concat(defaultUrl);
              }
              break;
            case 'bookmarks':
              urls = urls.concat(bookmarks);
              break;
            case 'history':
              urls = urls.concat(history);
              break;
            case 'search':
              if (defaultUrl.origin === 'search') {
                urls = urls.concat(defaultUrl);
              }
          }
        }
        return Post(msg.tab, {
          action: 'Dialog.draw',
          urls: urls,
          keyword: msg.keyword
        });
      };
      if (indexOf.call(completionItems, 'bookmarks') >= 0) {
        chrome.bookmarks.search(msg.keyword, function(bs) {
          bookmarks = bs;
          if (--dataToFetch === 0) {
            return returnUrls();
          }
        });
      }
      if (indexOf.call(completionItems, 'history') >= 0) {
        startTime = new Date().getTime() - 1000 * 60 * 60 * 24 * 10;
        return chrome.history.search({
          text: msg.keyword,
          maxResults: 30,
          startTime: startTime
        }, function(hs) {
          history = hs;
          if (--dataToFetch === 0) {
            return returnUrls();
          }
        });
      }
    };

    Tab.autoComplete.options = {
      completion_items: {
        description: 'Sets which items to complete and the order in which they appear',
        example: 'set completion_items=url,search-engine,bookmarks,history,search'
      }
    };

    Tab.openUrl = function(msg) {
      var url;
      url = fixUrl(msg.url, msg.tab).url;
      if (msg.incognito) {
        return chrome.windows.create({
          incognito: true,
          url: url
        }, function() {});
      } else {
        if (msg.newTab) {
          return chrome.tabs.create({
            url: url,
            index: msg.tab.index + 1,
            active: msg.active || Option.get('follow_new_tab') === 1
          });
        } else {
          return Tab.update({
            tab: msg.tab,
            url: url
          });
        }
      }
    };

    Tab.openFromClipboard = function(msg) {
      var url;
      url = Clipboard.read();
      return Tab.openUrl($.extend(msg, {
        url: url
      }));
    };

    Tab.reopen = function(msg) {
      var index, lastClosedTab;
      if (closedTabs.length > 0) {
        index = modulo(closedTabs.length - msg.count, closedTabs.length);
        lastClosedTab = closedTabs[index];
        if (lastClosedTab) {
          closedTabs.splice(index, 1);
          return chrome.tabs.create(lastClosedTab);
        }
      }
    };

    Tab.update = function(msg) {
      var tab;
      tab = msg.tab;
      delete msg.tab;
      return chrome.tabs.update(tab.id, msg, function(tab) {
        if (msg.callback) {
          return runWhenComplete({
            tab: tab,
            code: msg.callback
          });
        }
      });
    };

    Tab.move = function(msg) {
      var direction;
      direction = msg.direction === 'left' ? -1 : 1;
      return chrome.tabs.query({
        windowId: msg.tab.windowId
      }, function(tabs) {
        var newIndex;
        newIndex = modulo(msg.tab.index + msg.count * direction, tabs.length);
        return chrome.tabs.move(msg.tab.id, {
          index: newIndex
        });
      });
    };

    Tab.close = function(msg) {
      var cond, count, index, ref1, ref2, ref3;
      ref2 = [msg.type, (ref1 = msg.count) != null ? ref1 : 0], cond = ref2[0], count = ref2[1];
      index = (ref3 = msg.index) != null ? ref3 : msg.tab.index;
      if (msg.focusLast) {
        Tab.selectPrevious.apply('', arguments);
      }
      if (msg.offset) {
        Tab.select.apply('', arguments);
      }
      if (cond === 'otherWindows') {
        return chrome.windows.getAll({
          populate: true
        }, function(windows) {
          var i, len, w;
          for (i = 0, len = windows.length; i < len; i++) {
            w = windows[i];
            if (w.id !== msg.tab.windowId) {
              w.tabs.forEach(remove);
            }
          }
        });
      } else {
        return chrome.windows.getCurrent({
          populate: true
        }, function(w) {
          var i, len, ref4, tab;
          ref4 = w.tabs;
          for (i = 0, len = ref4.length; i < len; i++) {
            tab = ref4[i];
            if ((cond === 'closeOther' && tab.id !== msg.tab.id) || (cond === 'closeLeft' && tab.index < index && (count === 0 ? true : tab.index >= index - count)) || (cond === 'closeRight' && tab.index > index && (count === 0 ? true : tab.index <= index + count)) || (cond === 'closePinned' && tab.pinned) || (cond === 'closeUnPinned' && !tab.pinned) || (!cond && tab.index >= index && tab.index < index + Math.max(1, count))) {
              remove(tab);
            }
          }
        });
      }
    };

    Tab.select = function(msg) {
      return chrome.tabs.query({
        windowId: msg.tab.windowId
      }, function(tabs) {
        var index;
        if (msg.index != null) {
          index = Math.min(msg.index, tabs.length - 1);
        } else {
          index = modulo(msg.tab.index + msg.offset, tabs.length);
        }
        return Tab.update({
          tab: tabs[index],
          active: true
        });
      });
    };

    Tab.selectPrevious = function() {
      if (Tab.previousTab) {
        return Tab.update({
          tab: Tab.previousTab,
          active: true
        });
      }
    };

    Tab.selectLastOpen = function(msg) {
      var index;
      index = modulo(Tab.lastOpenTabs.length - msg.count, Tab.lastOpenTabs.length);
      return Tab.update({
        tab: Tab.lastOpenTabs[index],
        active: true
      });
    };

    Tab.toggleViewSource = function(msg) {
      var url;
      url = msg.tab.url.replace(/^(view-source:)?/, msg.tab.url.startsWith('view-source:') ? '' : 'view-source:');
      return Tab.openUrl($.extend(msg, {
        url: url
      }));
    };

    Tab.reload = function(msg) {
      var ref1;
      if (msg.reloadAll) {
        return chrome.tabs.query({
          windowId: msg.tab.windowId
        }, function(tabs) {
          var i, len, ref1, tab;
          ref1 = tabs.reverse();
          for (i = 0, len = ref1.length; i < len; i++) {
            tab = ref1[i];
            chrome.tabs.reload(tab.id);
          }
        });
      } else {
        return chrome.tabs.reload(msg.tab.id, {
          bypassCache: (ref1 = msg.bypassCache) != null ? ref1 : false
        });
      }
    };

    Tab.togglePin = function(msg) {
      return Tab.update({
        tab: msg.tab,
        pinned: !msg.tab.pinned
      });
    };

    Tab.unpinAll = function(msg) {
      return chrome.windows.getAll({
        populate: true
      }, function(windows) {
        var i, j, len, len1, ref1, tab, w;
        for (i = 0, len = windows.length; i < len; i++) {
          w = windows[i];
          ref1 = w.tabs;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            tab = ref1[j];
            if (tab.pinned && (msg.allWindows || w.id === msg.tab.windowId)) {
              Tab.update({
                tab: tab,
                pinned: false
              });
            }
          }
        }
      });
    };

    Tab.duplicate = function(msg) {
      var count, index, ref1, ref2;
      ref2 = [msg.tab.index, (ref1 = msg.count) != null ? ref1 : 1], index = ref2[0], count = ref2[1];
      while (count-- > 0) {
        chrome.tabs.create({
          url: msg.tab.url,
          index: ++index,
          active: false
        });
      }
    };

    Tab.detach = function(msg) {
      return chrome.windows.create({
        tabId: msg.tab.id,
        incognito: msg.tab.incognito
      });
    };

    Tab.makeLastTabIncognito = function() {
      var ref1, tab;
      ref1 = Tab.lastOpenTabs, tab = ref1[ref1.length - 1];
      if (tab) {
        return openInIncognito(tab);
      }
    };

    Tab.toggleIncognito = function(msg) {
      var incognito;
      incognito = !msg.tab.incognito;
      return chrome.tabs.query({
        windowId: msg.tab.windowId
      }, function(tabs) {
        return Window.moveTabToWindowWithIncognito(msg.tab, incognito, function(tab) {
          return chrome.tabs.remove(tab.id);
        });
      });
    };

    markTabs = function(msg, tabs) {
      var i, index, len, tab, title;
      for (i = 0, len = tabs.length; i < len; i++) {
        tab = tabs[i];
        index = markedTabs.indexOf(tab.id);
        if (index !== -1) {
          markedTabs.splice(index, 1);
        } else if (tab.url) {
          markedTabs.push(tab.id);
        }
      }
      title = markedTabs.length + " Tab(s) marked";
      return Post(msg.tab, {
        action: 'CmdBox.set',
        title: title,
        timeout: 4000
      });
    };

    Tab.markForMerging = function(msg) {
      if (msg.all) {
        return chrome.tabs.query({
          windowId: msg.tab.windowId
        }, function(tabs) {
          return markTabs(msg, tabs);
        });
      } else {
        return markTabs(msg, [msg.tab]);
      }
    };

    Tab.mergeMarkedTabs = function(msg) {
      if (markedTabs.length === 0) {
        return;
      }
      return chrome.windows.get(msg.tab.windowId, function(w) {
        var i, index, len, tabId;
        for (index = i = 0, len = markedTabs.length; i < len; index = ++i) {
          tabId = markedTabs[index];
          chrome.tabs.get(tabId, function(tab) {
            if (w.incognito === tab.incognito) {
              return chrome.tabs.move(tab.id, {
                windowId: w.id,
                index: -1
              });
            } else {
              chrome.tabs.create({
                windowId: w.id,
                url: tab.url
              });
              return chrome.tabs.remove(tab.id);
            }
          });
        }
        return markedTabs = [];
      });
    };

    Tab.addToClosedTabs = function(tab) {
      var i, index, len, t;
      for (index = i = 0, len = closedTabs.length; i < len; index = ++i) {
        t = closedTabs[index];
        if (!(tab.url === t.url)) {
          continue;
        }
        closedTabs.splice(index, 1);
        break;
      }
      if (tab.url !== 'chrome://newtab/') {
        return closedTabs.push({
          url: tab.url,
          index: tab.index
        });
      }
    };

    return Tab;

  })();

}).call(this);
